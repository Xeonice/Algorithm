//
// Created by 唐和辉 on 2018/4/26.
//

#include<stdio.h>

#define MaxN 1001
#define MinH -10001

int H[MaxN],size;


/*
    * 输入格式:
    * 每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。
    * 输出格式:
    * 对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。

    * 输入样例:
    * 5 3（堆的大小，打印节点数量）
    * 46 23 26 24 10（堆的元素）
    * 5 4 3（节点对应的下标）

    * 输出样例:
    * 24 23 10（第五个节点上溯的路径）
    * 46 23 10（第四个节点上溯的路径）
    * 26 10（第三个节点上溯的路径）
 */
void Create()
{
    size = 0;
    H[0] = MinH;//最小堆，因此哨兵最小
}

void Insert(int X)
{
    int i;
    for(i=++size;H[i/2]>X;i/=2)//父节点大于 X
        H[i] = H[i/2];//将父节点下移
    H[i] = X;//X 赋予应该在的位置
}

int main()
{
    int N,M,x;
    scanf("%d %d",&N,&M);
    Create();//建立堆
    for(int i=0;i<N;i++)
    {
        scanf("%d",&x);
        Insert(x);
    }
    int j;
    for(int i=0;i<M;i++)
    {
        scanf("%d",&j);//输入下标
        printf("%d",H[j]);//打印出当前下标对应的值
        while(j>1){//如果不为根节点
            j /= 2;//上溯节点
            printf(" %d",H[j]);//打印出当前下标对应的父节点
        }
        printf("\n");
    }

    return 0;
}
